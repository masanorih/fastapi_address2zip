# 住所→郵便番号変換システム 技術仕様書

## 概要

日本の住所文字列（例：「東京都港区六本木５丁目」「東京都千代田区神田小川町３−２２−１６」）から7桁郵便番号（例：「1060032」「1010052」）を取得するシステムの技術仕様書。

高精度かつ高速な検索を実現するために「階層インデックス + 正規化アプローチ」を採用。このアプローチは、日本の住所構造の階層性を活用したインデックス設計と、表記ゆれに対応する正規化処理を組み合わせた技術である。

## 問題設定

### 入力仕様
- **住所文字列**: 「東京都港区六本木５丁目」「東京都千代田区神田小川町３−２２−１６」
- **データソース**: ken_all.csv（日本郵便公式データ）

### 出力仕様
- **7桁郵便番号**: 「1060032」「1010052」

### データ構造仕様
**ken_all.csvフォーマット**:
```
団体コード,旧郵便番号,郵便番号,都道府県名カナ,市区町村名カナ,町域名カナ,都道府県名,市区町村名,町域名,一町域で二以上の郵便番号,小字毎に番地が起番されている町域,丁目で番地が起番されている町域,一つの郵便番号で二以上の町域,更新の表示,変更理由
```

**重要な列**:
- 列3: 郵便番号（7桁）
- 列7: 都道府県（漢字）  
- 列8: 市区町村（漢字）
- 列9: 町域名（漢字）

## 技術アーキテクチャ

### 1. 階層インデックス構造

#### データ構造設計
```python
address_index = {
    "都道府県": {
        "市区町村": {
            "町域名": "郵便番号"
        }
    }
}
```

#### 実装例
```python
{
    "東京都": {
        "港区": {
            "六本木": "1060032",
            "赤坂": "1070052"
        },
        "千代田区": {
            "神田小川町": "1010052"
        }
    },
    "大阪府": {
        "大阪市北区": {
            "梅田": "5300001"
        }
    },
    "北海道": {
        "札幌市中央区": {
            "北一条西": "0600001",
            "北二条西": "0600002"
        }
    }
}
```

#### 技術的特徴
- **O(1)検索性能**: 辞書アクセスによる定数時間検索
- **メモリ効率**: 階層構造による重複データの排除
- **スケーラビリティ**: 全国の住所データ（約12万件）を効率的に格納

### 2. 正規化処理システム

#### 2.1 文字表記正規化

**全角→半角変換**
```python
address = address.translate(str.maketrans(
    '０１２３４５６７８９', '0123456789'
))
```

**漢数字→算用数字変換**
```python
kanji_to_num = {
    '一': '1', '二': '2', '三': '3', '四': '4', '五': '5',
    '六': '6', '七': '7', '八': '八': '8', '九': '9', '十': '10'
}
```

#### 2.2 札幌住所特殊処理

**双方向数字変換**
- 漢数字→算用数字: 「北一条西」→「北1条西」
- 算用数字→漢数字: 「北1条西」→「北一条西」

```python
def _convert_kanji_numbers(self, address: str) -> str:
    # 条・丁目の漢数字変換
    address = re.sub(r'([一二三四五六七八九十])条', replace_kanji_jo, address)
    address = re.sub(r'([一二三四五六七八九十])丁目', replace_kanji_chome, address)
    return address

def _convert_arabic_to_kanji(self, district: str) -> str:
    # 逆方向変換
    district = re.sub(r'([0-9]+)条', replace_arabic_jo, district)
    district = re.sub(r'([0-9]+)丁目', replace_arabic_chome, district)
    return district
```

#### 2.3 政令指定都市対応

**複合市区町村名の解析**
```python
# 「大阪市北区」のような政令指定都市+区のパターン
city_match = re.match(r'(.*?市.*?区)', remaining)
if not city_match:
    # 通常の市区町村パターン
    city_match = re.match(r'(.*?[市区町村郡])', remaining)
```

#### 2.4 建物名・番地除去

**段階的除去処理**
```python
# 番地パターン（数字-数字-数字形式）
address = re.sub(r'[0-9]+[-−][0-9]+[-−]*[0-9]*.*$', '', address)

# 丁目の後の数字情報除去
address = re.sub(r'([0-9]+丁目)[0-9]+[-−].*$', r'\1', address)

# 建物名パターン除去
patterns = [r'ヒルズ.*$', r'タワー.*$', r'ビル.*$', ...]
```

### 3. 段階的検索アルゴリズム

#### 3.1 検索バリエーション生成

**町域名バリエーション**
```python
def generate_district_variants(self, district: str) -> list[str]:
    variants = [
        district,                                   # 元の住所
        self._convert_arabic_to_kanji(district),    # 漢数字版
        re.sub(r'[0-9]+丁目.*$', '', district),     # 丁目除去版
        # ... その他のバリエーション
    ]
    return unique_variants
```

**実例: 札幌住所**
- 入力: 「北1条西1丁目」
- バリエーション: ["北1条西1丁目", "北一条西一丁目", "北1条西", "北一条西"]

#### 3.2 多段階検索プロセス

**Phase 1: 完全一致検索**
```python
for variant in district_variants:
    if variant in city_districts:
        return city_districts[variant]
```

**Phase 2: フォールバック検索**
```python
for variant in district_variants:
    # 前方一致検索
    for stored_district, zipcode in city_districts.items():
        if stored_district.startswith(variant):
            return zipcode
    
    # 部分文字列検索
    for stored_district, zipcode in city_districts.items():
        if variant in stored_district:
            return zipcode
```

### 4. パフォーマンス特性

#### 時間計算量
- **インデックス構築**: O(n) - n = CSVレコード数
- **検索処理**: O(1) - 辞書アクセス
- **正規化処理**: O(m) - m = 住所文字列長

#### 空間計算量
- **インデックスサイズ**: 約10-20MB（全国住所データ）
- **メモリ使用量**: 階層構造により効率的

#### 実測パフォーマンス
- **初期化時間**: 約1-2秒（CSVパース + インデックス構築）
- **検索応答時間**: 1ms未満（単一住所）
- **テスト実行時間**: 1.1秒（48テストケース）

### 5. 対応住所パターン

#### 5.1 基本パターン
- 東京都港区六本木5丁目 → 1060032
- 東京都千代田区神田小川町3-22-16 → 1010052

#### 5.2 政令指定都市
- 大阪府大阪市北区梅田1丁目 → 5300001
- 愛知県名古屋市中区栄3丁目 → データに依存

#### 5.3 札幌特殊住所
- 北海道札幌市中央区北1条西1丁目 → 0600001
- 北海道札幌市中央区南3条東2丁目 → データに依存

### 6. エラーハンドリング戦略

#### 6.1 検索失敗時の対応
1. **完全一致失敗** → フォールバック検索実行
2. **フォールバック失敗** → null返却（404エラー）
3. **解析失敗** → 例外発生（500エラー）

#### 6.2 データ品質保証
- CSVファイル存在確認
- エンコーディング検証（UTF-8）
- 不正データレコードのスキップ

### 7. 拡張性考慮事項

#### 7.1 新住所パターン対応
- 正規化ルールの追加
- バリエーション生成ロジックの拡張
- テストケースの追加

#### 7.2 パフォーマンス最適化
- インデックスの永続化（キャッシュ）
- 検索頻度による優先度付け
- 並列処理の導入検討

### 8. 品質保証体制

#### 8.1 テスト戦略
- **単体テスト**: 正規化ロジック検証
- **統合テスト**: 実住所データでの検証
- **性能テスト**: 20秒制限の遵守確認

#### 8.2 テストカバレッジ
- 正規化処理: 19テストケース
- 住所解決: 16テストケース  
- WebAPI: 13テストケース
- **合計**: 48テストケース（実行時間: 1.1秒）

## 結論

階層インデックス + 正規化アプローチは、日本の複雑な住所体系に対して以下の利点を提供する：

1. **高精度**: 表記ゆれ対応により検索精度向上
2. **高速性**: O(1)検索による即座の応答
3. **保守性**: 明確な階層構造による機能拡張の容易さ
4. **スケーラビリティ**: 全国規模のデータに対応可能

このアプローチにより、実用的な住所→郵便番号変換システムを効率的に実現している。

## 代替手法比較

### 手法評価マトリックス

| 手法 | 精度 | 速度 | 実装難易度 | 表記ゆれ対応 | メモリ使用量 |
|------|------|------|------------|--------------|--------------|
| **階層インデックス** | ★★★★★ | ★★★★★ | ★★★☆☆ | ★★★☆☆ | ★★★☆☆ |
| 文字列完全一致 | ★★★☆☆ | ★★★★☆ | ★★★★★ | ★☆☆☆☆ | ★★★★★ |
| 正規表現マッチング | ★★★★☆ | ★★★☆☆ | ★★☆☆☆ | ★★☆☆☆ | ★★★★☆ |
| N-gram類似度 | ★★★☆☆ | ★★☆☆☆ | ★★☆☆☆ | ★★★★☆ | ★★☆☆☆ |
| 編集距離 | ★★☆☆☆ | ★☆☆☆☆ | ★★★☆☆ | ★★★★★ | ★★★★☆ |

### 各手法の詳細分析

#### 文字列完全一致
- **メリット**: 実装が最もシンプル、高速処理
- **デメリット**: 表記ゆれに全く対応できない
- **適用場面**: プロトタイプ、厳密な入力が保証される場合

#### 正規表現マッチング
- **メリット**: 柔軟なパターンマッチング、特定パターンに特化
- **デメリット**: 複雑な正規表現が必要、保守性が低い
- **適用場面**: 特定のパターンに特化した検索

#### N-gram類似度
- **メリット**: 部分的な文字列変化に対応、あいまい検索
- **デメリット**: 計算コストが高い、誤検出の可能性
- **適用場面**: あいまい検索が必要な場合

#### 編集距離
- **メリット**: 文字レベルの変化に最も柔軟に対応
- **デメリット**: 計算コストが非常に高い、実用性に課題
- **適用場面**: 高精度なあいまい検索が必要な研究用途

### 採用理由

**階層インデックス + 正規化アプローチ**が最適解である理由：

1. **高精度**: 構造化された検索で誤検出を最小化
2. **高速性**: O(1)の辞書アクセスによる即座の検索
3. **実装可能性**: 複雑すぎない適度な実装難易度
4. **保守性**: 明確な構造で機能追加・修正が容易
5. **実用性**: 住所検索という明確な用途に特化した効率的なアプローチ

## 運用考慮事項

### データ更新戦略
- **更新頻度**: ken_all.csvは月次更新（日本郵便公式）
- **インデックス再構築**: CSV更新時の自動化対応
- **差分更新**: 大量データの場合の検討事項
- **データ整合性**: 更新プロセス中のサービス継続性

### パフォーマンス最適化
- **インデックス永続化**: メモリ常駐によるキャッシュ効果
- **検索頻度分析**: 頻繁にアクセスされる住所の優先度付け
- **並列処理**: 大量リクエスト処理時の検討
- **メモリ最適化**: インデックス構造の効率化

### 品質保証体制
- **単体テスト**: 正規化ロジックの包括的検証
- **統合テスト**: 実際の住所データでの動作確認
- **性能テスト**: 大量データでの応答時間測定
- **回帰テスト**: システム変更時の既存機能保護
