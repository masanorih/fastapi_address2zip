# 階層インデックス + 正規化アプローチ技術詳細

## 概要

住所→郵便番号変換システムにおいて、高精度かつ高速な検索を実現するために「階層インデックス + 正規化アプローチ」を採用。
このアプローチは、日本の住所構造の階層性を活用したインデックス設計と、表記ゆれに対応する正規化処理を組み合わせた技術である。

## 技術アーキテクチャ

### 1. 階層インデックス構造

#### データ構造設計
```python
address_index = {
    "都道府県": {
        "市区町村": {
            "町域名": "郵便番号"
        }
    }
}
```

#### 実装例
```python
{
    "東京都": {
        "港区": {
            "六本木": "1060032",
            "赤坂": "1070052"
        },
        "千代田区": {
            "神田小川町": "1010052"
        }
    },
    "大阪府": {
        "大阪市北区": {
            "梅田": "5300001"
        }
    },
    "北海道": {
        "札幌市中央区": {
            "北一条西": "0600001",
            "北二条西": "0600002"
        }
    }
}
```

#### 技術的特徴
- **O(1)検索性能**: 辞書アクセスによる定数時間検索
- **メモリ効率**: 階層構造による重複データの排除
- **スケーラビリティ**: 全国の住所データ（約12万件）を効率的に格納

### 2. 正規化処理システム

#### 2.1 文字表記正規化

**全角→半角変換**
```python
address = address.translate(str.maketrans(
    '０１２３４５６７８９', '0123456789'
))
```

**漢数字→算用数字変換**
```python
kanji_to_num = {
    '一': '1', '二': '2', '三': '3', '四': '4', '五': '5',
    '六': '6', '七': '7', '八': '八': '8', '九': '9', '十': '10'
}
```

#### 2.2 札幌住所特殊処理

**双方向数字変換**
- 漢数字→算用数字: 「北一条西」→「北1条西」
- 算用数字→漢数字: 「北1条西」→「北一条西」

```python
def _convert_kanji_numbers(self, address: str) -> str:
    # 条・丁目の漢数字変換
    address = re.sub(r'([一二三四五六七八九十])条', replace_kanji_jo, address)
    address = re.sub(r'([一二三四五六七八九十])丁目', replace_kanji_chome, address)
    return address

def _convert_arabic_to_kanji(self, district: str) -> str:
    # 逆方向変換
    district = re.sub(r'([0-9]+)条', replace_arabic_jo, district)
    district = re.sub(r'([0-9]+)丁目', replace_arabic_chome, district)
    return district
```

#### 2.3 政令指定都市対応

**複合市区町村名の解析**
```python
# 「大阪市北区」のような政令指定都市+区のパターン
city_match = re.match(r'(.*?市.*?区)', remaining)
if not city_match:
    # 通常の市区町村パターン
    city_match = re.match(r'(.*?[市区町村郡])', remaining)
```

#### 2.4 建物名・番地除去

**段階的除去処理**
```python
# 番地パターン（数字-数字-数字形式）
address = re.sub(r'[0-9]+[-−][0-9]+[-−]*[0-9]*.*$', '', address)

# 丁目の後の数字情報除去
address = re.sub(r'([0-9]+丁目)[0-9]+[-−].*$', r'\1', address)

# 建物名パターン除去
patterns = [r'ヒルズ.*$', r'タワー.*$', r'ビル.*$', ...]
```

### 3. 段階的検索アルゴリズム

#### 3.1 検索バリエーション生成

**町域名バリエーション**
```python
def generate_district_variants(self, district: str) -> list[str]:
    variants = [
        district,                                    # 元の住所
        self._convert_arabic_to_kanji(district),    # 漢数字版
        re.sub(r'[0-9]+丁目.*$', '', district),     # 丁目除去版
        # ... その他のバリエーション
    ]
    return unique_variants
```

**実例: 札幌住所**
- 入力: 「北1条西1丁目」
- バリエーション: ["北1条西1丁目", "北一条西一丁目", "北1条西", "北一条西"]

#### 3.2 多段階検索プロセス

**Phase 1: 完全一致検索**
```python
for variant in district_variants:
    if variant in city_districts:
        return city_districts[variant]
```

**Phase 2: フォールバック検索**
```python
for variant in district_variants:
    # 前方一致検索
    for stored_district, zipcode in city_districts.items():
        if stored_district.startswith(variant):
            return zipcode
    
    # 部分文字列検索
    for stored_district, zipcode in city_districts.items():
        if variant in stored_district:
            return zipcode
```

### 4. パフォーマンス特性

#### 時間計算量
- **インデックス構築**: O(n) - n = CSVレコード数
- **検索処理**: O(1) - 辞書アクセス
- **正規化処理**: O(m) - m = 住所文字列長

#### 空間計算量
- **インデックスサイズ**: 約10-20MB（全国住所データ）
- **メモリ使用量**: 階層構造により効率的

#### 実測パフォーマンス
- **初期化時間**: 約1-2秒（CSVパース + インデックス構築）
- **検索応答時間**: 1ms未満（単一住所）
- **テスト実行時間**: 1.1秒（48テストケース）

### 5. 対応住所パターン

#### 5.1 基本パターン
- 東京都港区六本木5丁目 → 1060032
- 東京都千代田区神田小川町3-22-16 → 1010052

#### 5.2 政令指定都市
- 大阪府大阪市北区梅田1丁目 → 5300001
- 愛知県名古屋市中区栄3丁目 → データに依存

#### 5.3 札幌特殊住所
- 北海道札幌市中央区北1条西1丁目 → 0600001
- 北海道札幌市中央区南3条東2丁目 → データに依存

### 6. エラーハンドリング戦略

#### 6.1 検索失敗時の対応
1. **完全一致失敗** → フォールバック検索実行
2. **フォールバック失敗** → null返却（404エラー）
3. **解析失敗** → 例外発生（500エラー）

#### 6.2 データ品質保証
- CSVファイル存在確認
- エンコーディング検証（UTF-8）
- 不正データレコードのスキップ

### 7. 拡張性考慮事項

#### 7.1 新住所パターン対応
- 正規化ルールの追加
- バリエーション生成ロジックの拡張
- テストケースの追加

#### 7.2 パフォーマンス最適化
- インデックスの永続化（キャッシュ）
- 検索頻度による優先度付け
- 並列処理の導入検討

### 8. 品質保証体制

#### 8.1 テスト戦略
- **単体テスト**: 正規化ロジック検証
- **統合テスト**: 実住所データでの検証
- **性能テスト**: 20秒制限の遵守確認

#### 8.2 テストカバレッジ
- 正規化処理: 19テストケース
- 住所解決: 16テストケース  
- WebAPI: 13テストケース
- **合計**: 48テストケース（実行時間: 1.1秒）

## 結論

階層インデックス + 正規化アプローチは、日本の複雑な住所体系に対して以下の利点を提供する：

1. **高精度**: 表記ゆれ対応により検索精度向上
2. **高速性**: O(1)検索による即座の応答
3. **保守性**: 明確な階層構造による機能拡張の容易さ
4. **スケーラビリティ**: 全国規模のデータに対応可能

このアプローチにより、実用的な住所→郵便番号変換システムを効率的に実現している。
