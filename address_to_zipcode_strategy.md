# ken_all.csv住所→郵便番号変換の最適アプローチ

## 概要

日本の住所文字列（例：「東京都港区六本木５丁目」「東京都千代田区神田小川町３−２２−１６」）から
7桁郵便番号（例：「1060032」「1010052」）を取得するための技術的アプローチを分析し、最適解を提示する。

## 問題設定

### 入力
- 住所文字列: 「東京都港区六本木５丁目」「東京都千代田区神田小川町３−２２−１６」
- データソース: ken_all.csv（日本郵便公式データ）

### 出力
- 7桁郵便番号: 「1060032」「1010052」

### データ構造
ken_all.csvフォーマット：
```
団体コード,旧郵便番号,郵便番号,都道府県名カナ,市区町村名カナ,町域名カナ,都道府県名,市区町村名,町域名,一町域で二以上の郵便番号,小字毎に番地が起番されている町域,丁目で番地が起番されている町域,一つの郵便番号で二以上の町域,更新の表示,変更理由
```

重要な列：
- 列3: 郵便番号（7桁）
- 列7: 都道府県（漢字）  
- 列8: 市区町村（漢字）
- 列9: 町域名（漢字）

## 推奨アプローチ：階層インデックス + 正規化

### アーキテクチャ

```
住所文字列 → 正規化 → 階層検索 → 郵便番号
     ↓           ↓         ↓
"東京都港区六本木5丁目" → "東京都" + "港区" + "六本木" → "1060032"
"東京都千代田区神田小川町3-22-16" → "東京都" + "千代田区" + "神田小川町" → "1010052"
```

### 1. 階層インデックス構造

```python
address_index = {
    "東京都": {
        "港区": {
            "六本木": "1060032",
            "六本木（次のビルを除く）": "1060032",
            "赤坂": "1070052",
            # ...
        },
        "千代田区": {
            "神田小川町": "1010052",
            # ...
        }
    },
    "大阪府": {
        # ...
    }
}
```

### 2. 住所正規化ルール

#### 文字変換
- **全角数字→半角**: 「５」→「5」
- **全角英字→半角**: 「Ａ」→「A」
- **カタカナ→ひらがな**: 「ケ」→「ヶ」

#### 表記統一
- **丁目表記**: 「５丁目」→「5丁目」、「五丁目」→「5丁目」
- **番地除去**: 「六本木5丁目1-2-3」→「六本木5丁目」、「神田小川町３−２２−１６」→「神田小川町」
- **建物名除去**: 「六本木ヒルズ」→「六本木」

#### 特殊表記処理
- 括弧内情報の処理: 「（次のビルを除く）」等
- 階層表記の正規化: 「タワー（1階）」等

### 3. 検索アルゴリズム

#### Phase 1: 完全一致検索
```python
def exact_match(address: str) -> str:
    normalized = normalize_address(address)
    prefecture = extract_prefecture(normalized)
    city = extract_city(normalized)
    district = extract_district(normalized)
    
    try:
        return address_index[prefecture][city][district]
    except KeyError:
        return None
```

#### Phase 2: 段階的フォールバック
1. **前方一致検索**: 「六本木」で始まる町域
2. **部分文字列検索**: 「六本木」を含む町域
3. **最短マッチング**: 最も短い町域名を優先
4. **類似度検索**: 編集距離による近似マッチ

### 4. パフォーマンス特性

| 項目 | 仕様 |
|------|------|
| 検索速度 | O(1) - 辞書アクセス |
| メモリ使用量 | 10-20MB（全住所データ） |
| 初期化時間 | 1-2秒（CSVパース + インデックス構築） |
| データ更新 | CSVファイル更新時のみ再構築 |

## 代替アプローチ比較

| 手法 | 精度 | 速度 | 実装難易度 | 表記ゆれ対応 | メモリ使用量 |
|------|------|------|------------|--------------|--------------|
| **階層インデックス** | ★★★★★ | ★★★★★ | ★★★☆☆ | ★★★☆☆ | ★★★☆☆ |
| 文字列完全一致 | ★★★☆☆ | ★★★★☆ | ★★★★★ | ★☆☆☆☆ | ★★★★★ |
| 正規表現マッチング | ★★★★☆ | ★★★☆☆ | ★★☆☆☆ | ★★☆☆☆ | ★★★★☆ |
| N-gram類似度 | ★★★☆☆ | ★★☆☆☆ | ★★☆☆☆ | ★★★★☆ | ★★☆☆☆ |
| 編集距離 | ★★☆☆☆ | ★☆☆☆☆ | ★★★☆☆ | ★★★★★ | ★★★★☆ |

### 各手法の特徴

#### 文字列完全一致
- **メリット**: 実装が最もシンプル、高速
- **デメリット**: 表記ゆれに全く対応できない
- **用途**: プロトタイプ、厳密な入力が保証される場合

#### 正規表現マッチング
- **メリット**: 柔軟なパターンマッチング
- **デメリット**: 複雑な正規表現が必要、保守性が低い
- **用途**: 特定のパターンに特化した検索

#### N-gram類似度
- **メリット**: 部分的な文字列変化に対応
- **デメリット**: 計算コストが高い、誤検出の可能性
- **用途**: あいまい検索が必要な場合

## エラーハンドリング

### 検索結果の優先順位
1. **完全一致**: 正規化後の完全一致
2. **前方一致**: 町域名の前方一致
3. **部分一致**: 町域名に含まれる
4. **類似一致**: 編集距離による近似

### エラーケース
- **複数候補**: 最初に見つかった郵便番号を返却
- **見つからない場合**: nullまたは例外（設計方針による）
- **無効入力**: 適切なエラーメッセージ

## 運用考慮事項

### データ更新
- ken_all.csvは月次更新（日本郵便公式）
- インデックス再構築の自動化
- 差分更新の検討（大量データの場合）

### パフォーマンス最適化
- インデックスのメモリ常駐
- 検索頻度による優先度付け
- キャッシュ機能の実装

### 品質保証
- 単体テスト: 正規化ロジック
- 統合テスト: 実際の住所データでの検証
- 性能テスト: 大量データでの応答時間測定

## 結論

住所→郵便番号変換には**階層インデックス + 正規化**が最適解である。この手法は：

- **高精度**: 構造化された検索で誤検出を最小化
- **高速**: O(1)の辞書アクセスによる即座の検索
- **実装可能**: 複雑すぎない適度な実装難易度
- **保守性**: 明確な構造で機能追加・修正が容易

住所検索という明確な用途に特化した効率的なアプローチとして推奨する。
